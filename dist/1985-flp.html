<!DOCTYPE html><html><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/style.css">
<script id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-chtml-full.min.js"></script>
<script> MathJax = {tex: {inlineMath: [['$', '$']]}}; </script>
<title>Impossibility of Distributed Consensus with One Faulty Process (FLP) - JACM 1985</title>
</head><body lang="en-us">
<header> <a href="/">Home</a> </header>
<button id="btn">☀️</button>
<script src="/dark.js" ></script>

<div class="title">
<h1>Impossibility of Distributed Consensus with One Faulty Process</h1>
<p><span id="url">https://ying-zhang.cn/dist/1985-flp.html</span></p>
<p>MICHAEL J. FISCHER, <i>Yale University, New Haven, Connecticut</i><br/>
NANCY A. LYNCH, <i>Massachusetts Institute of Technology, Cambridge, Massachusetts</i><br/>
AND<br/>
MICHAEL S. PATERSON, <i>University of Warwick, Coventry, England</i></p>
<p><a href="https://www.podc.org/influential/2001-influential-paper/" target="_blank"><b>PODC 2001 Influential Paper Award</b></a></p>
</div>

<!-- <div class="s">
<p><b>Categories and Subject Descriptors:</b><br/>
  C.2.2 <b>[Computer-Communication Networks]</b>: Network Protocols—<i>protocol architecture</i>,<br/>
  C.2.4 <b>[Computer-Communication Networks]</b>: Distributed Systems—<i>distributed applications; distributed databases; network operating systems</i>;<br/>
  C.4 <b>[Performance of Systems]</b>: Reliability, Availability, and Serviceability;<br/>
  F.1.2 <b>[Computation by Abstract Devices]</b>: Modes of Computation—<i>parallelism</i>;<br/>
  H.2.4 <b>[Database Management]</b>: Systems—<i>distributed systems; transaction processing</i></p>
<p><b>General Terms</b>: Algorithms, Reliability, Theory</p>
<p><b>Additional Key Words and Phrases:</b> Agreement problem, asynchronous system, Byzantine Generals problem, commit problem, consensus problem, distributed computing, fault tolerance, impossibility proof, reliability</p>
</div> -->

<div class="copyright">
<p>Editing of this paper was performed by guest editor S. L. Graham. The Editor-in-Chief of JACM did not participate in the processing of the paper.</p>
<p>This work was supported in part by the Office of Naval Research under Contract N00014-82-K-0154, by the Office of Army Research under Contract DAAG29-79-C-0155, and by the National Science Foundation under Grants MCS-7924370 and MCS-8116678.</p>
<p>This work was originally presented at the 2nd ACM Symposium on Principles of Database Systems, March 1983.</p>
<p>Authors' present addresses: M. J. Fischer, Department of Computer Science, Yale University, P.O. Box 2158, Yale Station, New Haven, CT 06520; N. A. Lynch, Laboratory for Computer Science, Massachusetts Institute of Technology, 545 Technology Square, Cambridge, MA 02139; M. S. Paterson, Department of Computer Science, University of Warwick, Coventry CV4 7AL, England</p>
<p>Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission.</p>
<p>&copy; 1985 ACM 0004-5411/85/0400-0374 $00.75</p>
<p><i>Journal of the Association for Computing Machinery (JACM)</i>, Vol. 32, No. 2, April 1985, pp. 374-382.</p>
<p><b>DOI</b>: <a href="https://doi.org/10.1145/3149.214121">10.1145/3149.214121</a></p>
</div>

<p><b>Abstract.</b> The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. In this paper, it is shown that every protocol for this problem has the possibility of non-termination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the "Byzantine Generals" problem.</p>

<h1>1. Introduction</h1>
<p>The problem of reaching agreement among remote processes is one of the most fundamental problems in distributed computing and is at the core of many algorithms for distributed data processing, distributed file management, and fault-tolerant distributed applications.</p>
<p>A well-known form of the problem is the "transaction commit problem", which arises in distributed database systems [6, 13, 15-17, 21-24] (see also G. LeLann, private communication, quoted in [15]). The problem is for all the data manager processes that have participated in the processing of a particular transaction to agree on whether to install the transaction's results in the database or to discard them. The latter action might be necessary, for example, if some data managers were, for any reason, unable to carry out the required transaction processing. Whatever decision is made, all data managers must make the same decision in order to preserve the consistency of the database.</p>
<p>Reaching the type of agreement needed for the "commit" problem is straightforward if the participating processes and the network are completely reliable. However, real systems are subject to a number of possible faults, such as process crashes, network partitioning, and lost, distorted, or duplicated messages. One can even consider more Byzantine types of failure [5, 7, 8, 11, 14, 18, 19] in which faulty processes might go completely haywire, perhaps even sending messages according to some malevolent plan. One therefore wants an agreement protocol that is as reliable as possible in the presence of such faults. Of course, any protocol can be overwhelmed by faults that are too frequent or too severe, so the best that one can hope for is a protocol that is tolerant to a prescribed number of "expected" faults.</p>
<p>In this paper, we show the surprising result that no completely asynchronous consensus protocol can tolerate even a single unannounced process death. We do not consider Byzantine failures, and we assume that the message system is reliable—it delivers all messages correctly and exactly once. Nevertheless, even with these assumptions, the stopping of a single process at an inopportune time can cause any distributed commit protocol to fail to reach agreement. Thus, this important problem has no robust solution without further assumptions about the computing environment or still greater restrictions on the kind of failures to be tolerated!</p>
<p>Crucial to our proof is that processing is completely asynchronous; that is, we make no assumptions about the relative speeds of processes or about the delay time in delivering a message. We also assume that processes do not have access to synchronized clocks, so algorithms based on time-outs, for example, cannot be used. (In particular, the solutions in [6] are not applicable.) Finally, we do not postulate the ability to detect the death of a process, so it is impossible for one process to tell whether another has died (stopped entirely) or is just running very slowly.</p>
<p>Our impossibility result applies to even a very weak form of the consensus problem. Assume that every process starts with an initial value in $\set{0, 1}$. A non-faulty process decides on a value in $\set{0, 1}$ by entering an appropriate decision state. All non-faulty processes that make a decision are required to choose the same value. For the purpose of the impossibility proof, we require only that some process eventually make a decision. (Of course, any algorithm of interest would require that all non-faulty processes make a decision.) The trivial solution in which, say, 0 is always chosen is ruled out by stipulating that both 0 and 1 are possible decision values, although perhaps for different initial configurations.</p>
<p>Our system model is rather strong so as to make our impossibility proof as widely applicable as possible. Processes are modeled as automata (with possibly infinitely many states) that communicate by means of messages. In one atomic step, a process can attempt to receive a message, perform local computation on the basis of whether or not a message was delivered to it (and if so, which one), and send an arbitrary but finite set of messages to other processes. In particular, an "atomic broadcast" capability is assumed, so a process can send the same message in one step to all other processes with the knowledge that if any non-faulty process receives the message, then all the non-faulty processes will. Every message is eventually delivered as long as the destination process makes infinitely many attempts to receive, but messages can be delayed, arbitrarily long, and delivered out of order.</p>
<p>The asynchronous commit protocols in current use all seem to have a "window of vulnerability"—an interval of time during the execution of the algorithm in which the delay or inaccessibility of a single process can cause the entire algorithm to wait indefinitely. It follows from our impossibility result that every commit protocol has such a "window", confirming a widely believed tenet in the folklore.</p>

<h1>2. Consensus Protocols</h1>
<p>A <i>consensus protocol</i> $P$ is an asynchronous system of $N$ processes ($N \geq 2$). Each process $p$ has a one-bit <i>input register</i> $x_p$, an <i>output register</i> $y_p$ with values in $\{b, 0, 1\}$, and an unbounded amount of internal storage. The values in the input and output registers, together with the program counter and internal storage, comprise the <i>internal state</i>. <i>Initial states</i> prescribe fixed starting values for all but the input register; in particular, the output register starts with value $b$. The states in which the output register has value 0 or 1 are distinguished as being <i>decision states</i>. $p$ acts deterministically according to a <i>transition</i> function. The transition function cannot change the value of the output register once the process has reached a decision state; that is, the output register is "write-once." The entire system $P$ is specified by the transition functions associated with each of the processes and the initial values of the input registers.</p>
<p>Processes communicate by sending each other messages. A <i>message</i> is a pair $(p, m)$, where $p$ is the name of the destination process and $m$ is a "message value" from a fixed universe $M$. The <i>message system</i> maintains a multiset, called the <i>message buffer</i>, of messages that have been sent but not yet delivered. It supports two abstract operations:</p>
<style> dd {line-height: 1.5em; padding-left:5em} dt {float: left; line-height: 1.5em;} </style>
<dl>
<dt>$\text{send}(p,m)$:</dt> <dd>Places $(p, m)$ in the message buffer;</dd>
<dt>$\text{receive}(p)$:</dt> <dd>Deletes some message $(p, m)$ from the buffer and returns $m$, in which case we say $(p, m)$ is <i>delivered</i>, or returns the special null marker $\varnothing$ and leaves the buffer unchanged.</dd>
</dl>
<p></p>
<p>Thus, the message system acts non-deterministically, subject only to the condition that if $\text{receive}(p)$ is performed infinitely many times, then every message $(p, m)$ in the message buffer is eventually delivered. In particular, the message system is allowed to return $\varnothing$ a finite number of times in response to $\text{receive}(p)$, even though a message $(p, m)$ is present in the buffer.</p>
<p>A <i>configuration</i> of the system consists of the internal state of each process, together with the contents of the message buffer. An <i>initial configuration</i> is one in which each process starts at an initial state and the message buffer is empty.</p>
<p>A <i>step</i> takes one configuration to another and consists of a primitive step by a single process $p$. Let $C$ be a configuration. The step occurs in two phases. First, $\text{receive}(p)$ is performed on the message buffer in $C$ to obtain a value $m \in M \cup \{\varnothing\}$. Then, depending on $p$'s internal state in $C$ and on $m$, $p$ enters a new internal state and sends a finite set of messages to other processes. Since processes are deterministic, the step is completely determined by the pair $e = (p, m)$, which we call an <i>event</i>. (This "event" should be thought of as the receipt of $m$ by $p$.) $e(C)$ denotes the resulting configuration, and we say that $e$ can be <i>applied</i> to $C$. Note that the event $(p, \varnothing)$ can always be applied to $C$, so it is always possible for a process to take another step.</p>

<p>A <i>schedule</i> from $C$ is a finite or infinite sequence $\sigma$ of events that can be applied, in turn, starting from $C$. The associated sequence of steps is called a <i>run</i>. If $\sigma$ is finite, we let $\sigma(C)$ denote the resulting configuration, which is said to be <i>reachable</i> from $C$. A configuration reachable from some initial configuration is said to be <i>accessible</i>. Hereafter, all configurations mentioned are assumed to be accessible.</p>
<p>The following lemma expresses a "commutativity" property of schedules.</p>
<p><b>LEMMA 1</b>. <i>Suppose that from some configuration $C$, the schedules $\sigma_1$, $\sigma_2$, lead to configurations $C_1$, $C_2$, respectively. If the sets of processes taking steps in $\sigma_1$ and $\sigma_2$, respectively, are disjoint, then $\sigma_2$ can be applied to $C_1$ and $\sigma_1$ can be applied to $C_2$, and both lead to the same configuration $C_3$.</i> (See Figure 1.)</p>
<p><b>PROOF.</b> The result follows at once from the system definition, since $\sigma_1$ and $\sigma_2$ do not interact. □</p>
<p>A configuration $C$ has <i>decision value</i> $v$ if some process $p$ is in a decision state with $y_p = v$. A consensus protocol is <i>partially correct</i> if it satisfies two conditions:</p>
<ol style="list-style: none;">
<li>(1) No accessible configuration has more than one decision value.</li>
<li>(2) For each $v \in \set{0, 1}$, some accessible configuration has decision value $v$.</li>
</ol>
<p>A process $p$ is <i>non-faulty</i> in a run provided that it takes infinitely many steps, and it is <i>faulty</i> otherwise. A run is <i>admissible</i> provided that at most one process is faulty and that all messages sent to non-faulty processes are eventually received.</p>
<p>A run is a <i>deciding</i> run provided that some process reaches a decision state in that run. A consensus protocol $P$ is <i>totally correct in spite of one fault</i> if it is partially correct, and every admissible run is a deciding run. Our main theorem shows that every partially correct protocol for the consensus problem has some admissible run that is not a deciding run.</p>

<figure><img height="320px" src="1985-flp-cn/figs-en.svg"/></figure>

<h1>3. Main Result</h1>
<p><b>THEOREM 1.</b> <i>No consensus protocol is totally correct in spite of one fault</i>.</p>
<p><b>PROOF.</b> Assume to the contrary that $P$ is a consensus protocol that is totally correct in spite of one fault. We prove a sequence of lemmas which eventually lead to a contradiction.</p>
<p>The basic idea is to show circumstances under which the protocol remains forever indecisive. This involves two steps. First, we argue that there is some initial configuration in which the decision is not already predetermined. Second, we construct an admissible run that avoids ever taking a step that would commit the system to a particular decision.</p>
<p>Let $C$ be a configuration and let $V$ be the set of decision values of configurations reachable from $C$. $C$ is <i>bivalent</i> if $|V| = 2$. $C$ is <i>univalent</i> if $|V| = 1$, let us say <i>0-valent</i> or <i>1-valent</i> according to the corresponding decision value. By the total correctness of $P$, and the fact that there are always admissible runs, $V \ne \varnothing$. □</p>
<p><b>LEMMA 2.</b> <i>$P$ has a bivalent initial configuration</i>.</p>
<p><b>PROOF.</b> Assume not. Then $P$ must have both 0-valent and 1-valent initial configurations by the assumed partial correctness. Let us call two initial configurations <i>adjacent</i> if they differ only in the initial value $x_p$ of a single process $p$. Any two initial configurations are joined by a chain of initial configurations, each adjacent to the next. Hence, there must exist a 0-valent initial configuration $C_0$ adjacent to a 1-valent initial configuration $C_1$. Let $p$ be the process in whose initial value they differ.</p>
<p>Now consider some admissible deciding run from $C_0$ in which process $p$ takes no steps, and let $\sigma$ be the associated schedule. Then $\sigma$ can be applied to $C_1$ also, and corresponding configurations in the two runs are identical except for the internal state of process $p$. It is easily shown that both runs eventually reach the same decision value. If the value is 1, then $C_0$ is bivalent; otherwise, $C_1$ is bivalent. Either case contradicts the assumed nonexistence of a bivalent initial configuration. □</p>
<p><b>LEMMA 3.</b> <i>Let $C$ be a bivalent configuration of $P$, and let $e = (p, m)$ be an event that is applicable to $C$. Let $\mathscr{C}$ be the set of configurations reachable from $C$ without applying $e$, and let $\mathscr{D} = e(\mathscr{C}) = \{e(E) | E \in \mathscr{C}\ and$ $e$ $is\ applicable\ to\ \mathscr{C}\}$. Then, $\mathscr{D}$ contains a bivalent configuration</i>.</p>
<p><b>PROOF.</b> Since $e$ is applicable to $C$, then by definition of $\mathscr{C}$ and the fact that messages can be delayed arbitrarily, $e$ is applicable to every $E \in \mathscr{C}$.</p>
<p>Now assume that $\mathscr{D}$ contains no bivalent configurations, so every configuration $D \in \mathscr{D}$ is univalent. We proceed to derive a contradiction.</p>
<p>Let $E_i$ be an $i$-valent configuration reachable from $C$, $i = 0, 1$. ($E_i$ exists since $C$ is bivalent.) If $E_i \in \mathscr{C}$, let $F_i = e(E_i) \in \mathscr{D}$. Otherwise, $e$ was applied in reaching $E_i$, and so there exists $F_i \in \mathscr{D}$ from which $E_i$ is reachable. In either case, $F_i$ is $i$-valent since $F_i$ is not bivalent (since $F_i \in \mathscr{D}$ and $\mathscr{D}$ contains no bivalent configurations) and one of $E_i$ and $F_i$ is reachable from the other. Since $F_i \in \mathscr{D}$, $i = 0, 1$, $\mathscr{D}$ contains both 0-valent and 1-valent configurations.</p>
<p>Call two configurations <i>neighbors</i> if one results from the other in a single step. By an easy induction, there exist neighbors $C_0,\ C_1 \in \mathscr{C}$ such that $D_i = e(C_i)$ is $i$-valent, $i = 0, 1$. Without loss of generality, $C_1 = e'(C_0)$ where $e'=(p',m')$.</p>
<p><i>Case</i> 1 . If $p' \ne p$, then $D_1 = e'(D_0)$ by Lemma 1. This is impossible, since any successor of a 0-valent configuration is 0-valent. (See Figure 2.)</p>
<p><i>Case</i> 2. If $p' = p$, then consider any finite deciding run from $C_0$ in which $p$ takes no steps.</p>
<p>Let $\sigma$ be the corresponding schedule, and let $A = \sigma(C_0)$. By Lemma 1, $\sigma$ is applicable to $D_i$, and it leads to an $i$-valent configuration $E_i = \sigma(D_i)$, $i = 0, 1$. Also by Lemma 1, $e(A) = E_0$ and $e(e'(A)) = E_1$. (See Figure 3.) Hence, $A$ is bivalent. But this is impossible since the run to $A$ is deciding (by assumption), so $A$ must be univalent.</p>
<p>In each case, we reached a contradiction, so $\mathscr{D}$ contains a bivalent configuration. □</p>
<p>Any deciding run from a bivalent initial configuration goes to a univalent configuration, so there must be some single step that goes from a bivalent to a univalent configuration. Such a step determines the eventual decision value. We now show that it is always possible to run the system in a way that avoids such steps, leading to an admissible non-deciding run.</p>
<p>The run is constructed in stages, starting from an initial configuration. We ensure that the run is admissible in the following way. A queue of processes is maintained, initially in an arbitrary order, and the message buffer in a configuration is ordered according to the time the messages were sent, earliest first. Each stage consists of one or more process steps. The stage ends with the first process in the process queue taking a step in which, if its message queue was not empty at the start of the stage, its earliest message is received. This process is then moved to the back of the process queue. In any infinite sequence of such stages every process takes infinitely many steps and receives every message sent to it. The run is therefore admissible. Our problem, of course, is to do this in such a way as to avoid a decision ever being reached.</p>
<p>Let $C_0$ be a bivalent initial configuration whose existence is assured by Lemma 2. Execution begins in $C_0$, and we ensure that every stage begins from a bivalent configuration. Suppose then that configuration $C$ is bivalent and that process $p$ heads the priority queue. Let $m$ be the earliest message to $p$ in $C$'s message buffer, if any, and $\varnothing$ otherwise. Let $e = (p, m)$. By Lemma 3, there is a bivalent configuration $C'$ reachable from $C$ by a schedule in which $e$ is the last event applied. The corresponding sequence of steps defines the stage.</p>
<p>Since each stage ends in a bivalent configuration, every stage in the construction of the infinite schedule succeeds. The resulting run is admissible, and no decision is ever reached. It follows that $P$ is not totally correct. □</p>

<h1>4. Initially Dead Processes</h1>
<p>In this section, we exhibit a protocol that solves the consensus problem for $N$ processes as long as a majority of the processes are non-faulty and no process dies during the execution of the protocol. No process knows in advance, however, which of the processes are initially dead and which are not.</p>
<p>The protocol works in two stages. During the first stage, the processes construct a directed graph $G$ with a node corresponding to each process. Every process broadcasts a message containing its process number and then listens for messages from $L-1$ other processes, where $L = \lceil (N + 1)/2\rceil$. $G$ has an edge from $i$ to $j$ iff $j$ receives a message from $i$. Thus, $G$ has in-degree $L-1$.</p>
<p>In the second stage, the processes construct $G^+$ (the transitive closure of $G$) in the sense that upon completion of this stage, each process $k$ knows about all of the edges $(j, k)$ incident on $k$ in $G^+$ as well as the initial values of all such $j$.</p>
<p>To carry out this stage, each process broadcasts to all other processes its process number and initial value together with the names of the $L-1$ processes it heard from during the first stage. It then waits until it has received a stage 2 message from every ancestor in $G$ that it knows about. Initially, it knows only about the $L-1$ processes from which it heard directly during the first stage, but it learns about additional ancestors from the stage 2 messages that it receives. Waiting continues until such time as all currently known-about processes have been heard from.</p>
<p>At this point, each process knows all of its own ancestors and the edges of $G$ incident on them. Using this information, it computes all of the edges of $G^+$ incident on each of its ancestors. It then determines which of its ancestors belong to an <i>initial</i> clique of $G^+$, that is, a clique with no incoming edges. To do this, it uses the fact that a node $k$ is in an initial clique iff $k$ is itself an ancestor of every node $j$ that is an ancestor of $k$. Since every node in $G^+$ has at least $L-1$ predecessors, there can be only one initial clique; it has cardinality at least $L$, and every process that completes the second stage knows exactly the set of processes comprising it.</p>
<p>Finally, each process makes a decision based on the initial values of the processes in the initial clique using any agreed-upon rule. Since all processes know the initial values of all members of the initial clique, they all reach the same decision.</p>
<p>The correctness of this protocol proves the following theorem.</p>
<p><b>THEOREM 2.</b> <i>There is a partially correct consensus protocol in which all non-faulty processes always reach a decision, provided no processes die during its execution and a strict majority of the processes are alive initially</i>.</p>

<h1>5. Conclusion</h1>
<p>We have shown that a natural and important problem of fault-tolerant cooperative computing cannot be solved in a totally asynchronous model of computation. These results do not show that such problems cannot be "solved" in practice; rather, they point up the need for more refined models of distributed computing that better reflect realistic assumptions about processor and communication timings, and for less stringent requirements on the solution to such problems. (For example, termination might be required only with probability 1.) Subsequent to the original announcement of these results [12], progress has been made along both of these lines [1-4, 9, 10, 20, 25].</p>

<p><b>ACKNOWLEDGMENT.</b> The authors would like to thank John Guttag for helpful discussions during the initial phase of this work, and Gene Stark for discussion of the results and a careful reading of the text. They also thank the referees for pointing out several places where the presentation needed improvement.</p>

<h1 style="page-break-before: always;">REFERENCES</h1>
<ol class="bib">
<li>ATTIYA, C., DOLEV, D., AND GIL, J. Asynchronous Byzantine consensus. In <i>Proceedings of the 3rd Annual ACM Symposium on Principles of Distributed Computing</i> (Vancouver, B.C., Canada, Aug. 27-29). ACM, New York, 1984, pp. 119-133.</li>
<li>BEN-OR, M. <a href="/dist/1983-ben-or.html" target="_blank">Another Advantage of Free Choice: Completely Asynchronous Agreement Protocols.</a> In <i>Proceedings of the 2nd Annual ACM Symposium on Principles of Distributed Computing</i> (Montreal, Quebec, Canada, Aug. 17-19). ACM, New York, 1983, pp. 27-30.</li>
<li>BRACHA, G. An asynchronous ⌊(n-1)/3⌋-resilient consensus protocol. In <i>Proceedings of the 3rd Annual ACM Symposium on Principles of Distributed Computing</i> (Vancouver, B.C., Canada, Aug. 27-29). ACM, New York, 1984, pp. 154-162.</li>
<li>BRACHA, G., AND TOUEG, S. Resilient consensus protocols. In <i>Proceedings of the 2nd Annual ACM Symposium on Principles of Distributed Computing</i> (Montreal, Quebec, Canada, Aug. 17-19). ACM, New York, 1983, pp. 12-26.</li>
<li>DEMILLO, R. A., LYNCH, N. At, AND MERRITT, M. J. Cryptographic protocols. In <i>Proceedings of the 14th Annual ACM Symposium on Theory of Computing</i> (San Francisco, Calif., May 5-7). ACM, New York, 1982, pp. 383-400.</li>
<li>DOLEV, D., AND STRONG, H. R. Distributed commit with bounded waiting. In <i>Proceedings of the 2nd Annual IEEE Symposium on Reliability in Distributed Software and Database Systems</i>. IEEE, New York, 1982, pp. 53-60.</li>
<li>DOLEV, D., AND STRONG, H. R. Polynomial algorithms for multiple processor agreement. In <i>Proceedings of the 14th Annual ACM Symposium on Theory of Computing</i> (San Francisco, Calif., May 5-7). ACM, New York, 1982, pp. 401-407.</li>
<li>DOLEV, D., FISCHER, M., FOWLER, R., LYNCH, N., AND STRONG, H. R. An efficient algorithm for Byzantine agreement without authentication. <i>Inf. Control</i> 52, 3 (1983), 257-274.</li>
<li>DOLEV, D., LYNCH, N., PINTER, S., STARK, E., AND WEIHL, W. Reaching approximate agreement in the presence of faults. In <i>Proceedings of the 3rd Annual IEEE Symposium on Reliability in Distributed Software and Database Systems</i>. IEEE, New York, 1983, pp. 145-154.</li>
<li>DWORK, C., LYNCH, N., AND STOCKMEYER, L. Consensus in the presence of partial synchrony. In <i>Proceedings of the 3rd Annual ACM Symposium on Principles of Distributed Computing</i> (Vancouver, B.C., Canada, Aug. 27-29). ACM, New York, 1984, pp. 103-118.</li>
<li>FISCHER, M., AND LYNCH. N. A lower bound for the time to assure interactive consistency. <i>Inf. Proc. Lett.</i> 14, 4 (1982), 183-186.</li>
<li>FISCHER, M., LYNCH, N., AND PATERSON, M. Impossibility of distributed consensus with one faulty process. In <i>Proceedings of the 2nd Annual ACM SIGACT-SIGMOD Symposium on Principles of Database Systems</i> (Atlanta, Ga., Mar. 21-23). ACM, New York, 1983, pp. 1-7.</li>
<li>GARCIA-MOLINA, H. Elections in a distributed computing system. <i>IEEE Trans. Comput.</i> C-31, 1 (1982), 48-59.</li>
<li>LAMPORT, L., SHOSTAK, R., AND PEASE, M. The Byzantine Generals problem. <i>ACM Trans. Prog. Lang. syst.</i> 4, 3 (July 1982), 382-401.</li>
<li>LAMPSON, B. Replicated Commit. CSL Notebook Entry, Xerox Palo Alto Research Center, Palo Alto, Calif., 1981.</li>
<li>LAMPSON, B., AND STURGIS, H. Crash recovery in a distributed data storage system. Manuscript, Xerox Palo Alto Research Center, Palo Alto, Calif., 1979.</li>
<li>LINDSAY, B. G. , SELINGER, P. G., GALTIERI, C., GRAY, J. N., LORIE, R. A., PRICE, T. G., PUTZOLU, F., TRAIGER, I. L., AND WADE, B. W. Notes on distributed databases. IBM Res. Rep. RJ2571, IBM Research Division, San Jose, Calif., 1979.</li>
<li>LYNCH, N., FISCHER, M., AND FOWLER, R. A simple and efficient Byzantine Generals algorithm. In <i>Proceedings of the 2nd Annual IEEE Symposium on Reliability in Distributed Software and Database Systems</i>. IEEE, New York, 1982, pp. 46-52.</li>
<li>PEASE, M., SHOSTAK, R., AND LAMPORT, L. Reaching agreement in the presence of faults. <i>J. ACM</i> 27, 2 (Apr. 1980), 228-234.</li>
<li>RABIN, M. Randomized Byzantine Generals. In <i>Proceedings of the 24th Annual IEEE Symposium on Foundations of Computer Science</i>. IEEE, New York, 1983, pp. 403-409.</li>
<li>REED, D. Naming and synchronization in a decentralized computer system. Ph.D. dissertation, Technical Report MIT/LCS/TR-205, Massachusetts Institute of Technology, Cambridge, Mass., 1978.</li>
<li>ROSENKRANTZ, D. J., STEARNS, R. E., AND LEWIS, P. M., II. System level concurrency control for distributed database systems. <i>ACM Trans. Database Syst.</i> 3, 2 (June 1978), 178-198.</li>
<li>SKEEN, D. A decentralized termination protocol. In <i>Proceedings of the 2nd Annual IEEE Symposium on Reliability in Distributed Software and Database Systems</i>. IEEE, New York, 1982, pp. 27-32.</li>
<li>SKEEN, D., AND STONEBRAKER, M. A formal model of crash recovery in a distributed system. <i>IEEE Trans. Softw. Engineering</i> SE-9, 3 (May 1983), 219-228.</li>
<li>TOUEG, S. Randomized Byzantine Agreements. In <i>Proceedings of the 3rd Annual ACM Symposium on Principles of Distributed Computing</i> (Vancouver, B.C., Canada, Aug. 27-29). ACM, New York, 1984, PP. 163-178.</li>
</ol>

<p>RECEIVED SEPTEMBER 1983; REVISED OCTOBER 1984; ACCEPTED OCTOBER 1984</p>
</body> </html>